# Интересные задачи вычислительной физики

## Интерполяции

Пусть у нас есть N точек на плоскости. Тогда существует и единственнен полином порядка N, который проходит через все эти точки.

### Метод лагранжа

У нас есть удобная формула для построения таких полиномов.

![image](https://user-images.githubusercontent.com/25401699/142418585-b8c0c74f-1e59-448f-96c0-5981f8ef7635.png)

### Пример

![image](https://user-images.githubusercontent.com/25401699/142419809-e843eed9-ff60-4990-9774-6138e4d86aa5.png)

## Численное дифференцирование

Задача такая - есть непрерывная функция, нужно взять ее первую и вторую производные.

### Простейший случай

Самый простой вариант - это первая производная с первым порядком точности, где погрешность пропорциональна порядку разбиения.

```
f'n = [f(Xn+1) - f(Xn)] / h;
Xn - сетка аргумента.
f - наша непрерывная функция.
h - размер разбиения.
f'n - сетка производной функции.
```

### Большая точность

Но если мы хотим большую точность, то нам нужно взять несколько узлов сетки, построить интерполяционный полином и взять производную.
Таким образом можно находить любые производные с любым порядком точности.

### Пример

![](https://github.com/timattt/Project-computational-math/blob/master/Images/DiffExample.png)

## Решение задачи Коши для обыкновенного дифференциального уравнения

Имеем такое уравнение:
```
dy
-- = f(x, y)
dx
```
Имеем начальное условие:
```
f(x0) = y0
```
Переменная **y**, вообще говоря может быть вектором.
Наша задача - решить уравнение, т.е. получить два массива - значения **x** и **y** - т.е. их зависимость.

### Явный метод Эйлера

Самый простой путь решения просто представить dx малым числом и приблизить дифференциал.
То есть, если первую точки итоговой кривой (x0, y0) мы уже знаем, то следующая точка сетки вычисляется вот так:

$$
y_1 = f(x_0, y_0) * h + y_0
$$

![image](https://user-images.githubusercontent.com/25401699/145378708-d6481b69-1282-44a9-a1cf-78529644c305.png)

### Метод Рунге-Кутты

Самый популярный метод численного решения ЗК 4ого порядка.

![image](https://user-images.githubusercontent.com/25401699/145380431-19e3c881-2c3d-403d-a81f-9a481f75b7dc.png)

### Примеры решения дифуров

![image](https://user-images.githubusercontent.com/25401699/145378783-9ccec97a-8f02-4dd5-ab07-d716086c9fca.png)

![image](https://user-images.githubusercontent.com/25401699/145380146-51a8abad-4f0a-4916-aff9-8a5ae8dca733.png)

![image](https://user-images.githubusercontent.com/25401699/145380355-1af24fb0-2d98-4c98-9180-65d9b7c8c43c.png)

![image](https://user-images.githubusercontent.com/25401699/145380453-d61fdc5d-7de8-43e3-8875-4cc53f62a42a.png)

## Задача N тел

## Интегрирование уравнения движения методом Рунге-Кутты

Пусть нам заданы **N** тел. У каждого известны:
1. масса
2. начальное положение
3. начальная скорость   

Запишем **II закон Ньютона** для каждого тела.
Мы умеем решить задачу Коши для ОДУ. Т.е. уравнения вида:
```
dX
-- = f(X, t)
dt
```
Где **X** является вектором.
Поэтому, переходя в **4N-мерное пространство**, получаем вот такую систему ОДУ:

<img src="https://user-images.githubusercontent.com/25401699/149898481-8e4bcf39-f6c3-47f9-b296-57efd80fd9b8.png" alt="drawing" width="500"/>

Теперь нам необходимо получить достаточно точное решение.
Воспользуемся методом **Рунге-Кутты**.

Имеем рекуррентную формулу на каждую следующую точку 4N-мерного пространства в сетке. 

<img src="https://user-images.githubusercontent.com/25401699/149899827-39144f5c-50ec-449c-b60c-acfb2a1c4a24.png" alt="drawing" width="500"/>

Отметим так же, что данный метод имеет 4-ый порядок точности, что позволяет немного сэкономить на вычислительной мощности.
Однако, погрешность зависит от максимума второй производной интегрируемой функции ОДУ. Так как функция обратна пропорциональна расстоянию до тела, то при сближении двух тел точность будет очень сильно снижаться. Что выражается в резких отталкиваниях объектов друг от друга на бесконечность. При этом будут нарушены любые аналитические закономерности, в частности, тело может покинуть потенциальную яму, что в идеальных условиях было бы невозможно.

## Задача 2-ух тел

Как известно, в задаче двух тел центр масс двигается поступательно, а тела относительно центра масс двигаются по эллиптической орбите.

### Пример 1

Два тела с одинаковыми массами

![2bp1](https://user-images.githubusercontent.com/25401699/149902317-dc2415e8-07d3-4e0a-903f-c668c6ccd9e7.gif)

### Пример 2

Одно из тел в десять раз тяжелее другого

![2bp2](https://user-images.githubusercontent.com/25401699/149902841-9bcda0df-e36d-4213-8096-a833945e1b20.gif)

В данном случае скорость легкого тела соответствовала первой космической, относительно второго тела. Поэтому оно двигается по орбите.
В следующем примере будет иначе.

### Пример 3

![2b3](https://user-images.githubusercontent.com/25401699/149904528-9e67be42-aa9f-4f6d-bf20-951ba23cd428.gif)

Здесь наблюдается параболическое движение. Т.к. начальная скорость первого тела больше второй космической.

## Гравитационный маневр

В предыдущем примере можно заметить, что скорость легкого тела после пролета мимо тяжелого тела изменилась.
При этом никаких других сил в расчете не было. Т.е. использую сторонние космические тела мы можем изменять скорость выбранного тела, если направить его на параболическую орбиту
вокруг тяжелого тела. В этом и заключается смысл гравитационного маневра.

Рассмотрим несколько примеров, причем в этот раз будет отслеживать изменение кинетической энергии исследуемого тела.

### Пример 4

Пример гравитационного замедления.

![gm1](https://user-images.githubusercontent.com/25401699/149906301-723b4b6f-0ae7-4d9c-8316-6bd412505d93.gif)

### Пример 5

Пример гравитационного ускорения.

![gm2](https://user-images.githubusercontent.com/25401699/149907864-e1099d6a-42fd-4d5b-abbe-bed4fc2a585e.gif)

### Пример 6

![oe1](https://user-images.githubusercontent.com/25401699/149913368-ec238545-09e5-42c5-86b1-5714f18e11eb.gif)

Видно, что наиболее выгодно включать двигатель в перицентре параболической орбиты.

## Задача 3-х тел

Возьмем три тела и сразу рассмотрим несколько примеров.

### Пример 7

Два тела изначально двигались по эллиптической орбите, но прилет третьего все сломал, в результате все три двигаются в бесконечность отдельно.

![3bp1](https://user-images.githubusercontent.com/25401699/149921451-5b09f79f-c607-43c2-bf5a-e4c7cd9c9377.gif)

### Пример 8

Два тела изначально двигались по эллиптической орбите, но прилет третьего заставил одно тело улететь на бесконечность, а два других образовали новую эллиптическую орбиту.   
Этакий "любовный" треугольник.

![3bp2](https://user-images.githubusercontent.com/25401699/149921632-5fa22880-0ec8-4138-821c-d37ed958eadf.gif)

### Пример 9

Здесь в центре располагается массивное тело. Вокруг него по эллиптическим орбитам летают два других легких тела.

![3bp3](https://user-images.githubusercontent.com/25401699/149922026-ed091924-3902-4d55-8788-c5be45757207.gif)

### Пример 10

Взаимодействие двух легких тел с одним тяжелым.

![3bp4](https://user-images.githubusercontent.com/25401699/149922144-96b132a9-dc0e-4383-8b05-5854dcb7176f.gif)

### Пример 11

Этот моделирует поведение **двойной звезды**.

![3bp5](https://user-images.githubusercontent.com/25401699/149922278-c59ce400-969c-456a-8ece-2f2087ca04e5.gif)

## Приближенная модель солнечной системы

Теперь посмотрим, что будет если тел будет порядка 10.
Попробуем создать солнечную систему с 9 планетами и 1 тяжелой звездой в центре.

### Пример 12

Это абсолютно симметричное движение в псевдо-солнечной системе.

![ss1](https://user-images.githubusercontent.com/25401699/149923125-21065812-5478-4a6d-acd7-38eeb4fcb32a.gif)

### Пример 13

Рассмотрим хаос в псевдо-солнечной системе.

![ss2](https://user-images.githubusercontent.com/25401699/149923977-aade2da2-2484-4462-b155-ebb6e2e734fc.gif)

### Пример 14

Еще один пример хаоса. В итоге псевдо-солнечная система полностью рассыпалась.

![ss3](https://user-images.githubusercontent.com/25401699/149925215-b069b945-26e2-4322-8049-66cb26778602.gif)

## Интегрирование

### Левые или правые прямоугольники

Делим отрезок на n равноудаленных точек. Суммируем прямоугольники, берем левую или правую точку.

```
I = sum f(xi) * (xi+1 - xi)
     i
```

![image](https://user-images.githubusercontent.com/25401699/144395312-9849b2eb-e4be-4bce-80ae-5d1e4c9d44e5.png)

### Центральные прямоугольники

Аналогично предыдущему пункту, но теперь берем центральные точку подотрезков.

```
I = sum f(xi+0.5) * (xi+1 - xi)
     i
```

![image](https://user-images.githubusercontent.com/25401699/144395581-046636b4-9d7f-4850-9bc1-c4f48d0c7042.png)

### Трапеции

Тепепь суммируем трапеции с вершинами в крайних точках.

```
I = sum 0.5 * (f(xi) + f(xi+1)) * (xi+1 - xi)
     i
```

![image](https://user-images.githubusercontent.com/25401699/144395755-0ffe1c97-a600-4623-ad56-ea329202108a.png)

### Правило Симпсона

Теперь будем апроксимировать подкривые параболами.

```
I = sum 1/6 * (f(xi) + 4*f(xi+0.5) + f(xi+1)) * (xi+1 - xi)
     i
```

![image](https://user-images.githubusercontent.com/25401699/144398601-fc3b1255-b6e8-489b-a306-db6431f15ed2.png)

### Интегрирование по монтекарло

Алгоритм основывается на случайных числах.
Будем рандомить точки, если точка попадает в интегрируемую область - увеличим число K. Всего точек - N.
Тогда если имеем отрезок [a, b].
И еще:
```
y0 = min(f(x))
y1 = max(f(x)).
S0 = (b - a) * (y1 - y0)
```
Тогда окончательно интеграл равен 
```
S = S0 * K / N
```

![image](https://user-images.githubusercontent.com/25401699/144396801-0e8629a3-4259-4da8-8307-e66e53b0cb1e.png)

## Одномерное уравнение мелкой воды


Имеем вот такую систему.

$$
\begin{cases}
   \frac{\partial H}{\partial t} + \frac{\partial (H u)}{\partial x} = 0\\
  \frac{\partial (H u)}{\partial t} + \frac{\partial (H u^2)}{\partial x} + g H \frac{\partial H}{\partial x} = 0
\end{cases}\
$$

Где u - скорость слоя жидкости. H - высота слоя жидкости.

Перепишем в матричном виде:

$$
\begin{pmatrix}
\frac{\partial H}{\partial t} \\
\frac{\partial u}{\partial t}
\end{pmatrix}
+
\begin{pmatrix}
u & H \\
g & u
\end{pmatrix}
*
\frac{\partial}{\partial x}
\begin{pmatrix}
H \\
u
\end{pmatrix}
\text{=}
\vec 0
$$

Найдем собственные числа.

$$
\det \begin{pmatrix}
u -\lambda & H \\
g & u - \lambda
\end{pmatrix} \text{=} (u - \lambda)^2 - g H \text{=} 0
$$

$$
\lambda_{1,2} = u \pm c
$$

где 

$$
c = \sqrt{g H}
$$

Тогда легко найти собственные векторы:

$$
\vec l_1 = 
\begin{pmatrix}
-c & H
\end{pmatrix}
$$

$$
\vec l_2 = 
\begin{pmatrix}
c & H
\end{pmatrix}
$$

Теперь мы умножаем исходную систему в матричном виде на собственные векторы слева. Произведение матрицы и ее собственного вектора преобразуем
по определению собственного вектора. И получаем два выражения.

$$
-(H_t + \lambda_1 H_x) c + (u_t + \lambda_1 u_x) H = 0
$$

$$
(H_t + \lambda_2 H_x) c + (u_t + \lambda_2 u_x) H = 0
$$

Теперь во имя устойчивости при апроксимации по координате введем такой оператор:

$$
L_{\lambda_k}[U]_i^{j} = [\lambda_i^j]_+ \frac{U_i^j - U_{i-1}^j}{h} + [\lambda_{i}^{j}]_- \frac{U_{i-1}^j - U_{i}^{j}}{h}
$$

где

$$
[\lambda_i^j]_+ = \frac{\lambda_i^j + |\lambda_i^j|}{2}
$$

$$
[\lambda_i^j]_- = \frac{\lambda_i^j - |\lambda_i^j|}{2}
$$

Отметим, определение устойчивости слудует из спектрального критерия Неймана.
Будем аппроксимировать таким образом:

$$
\lambda_k U_x \approx L_{\lambda_k}[U]_i^{j}
$$

$$
U_t \approx \frac{U_i^{j+1} - U_i^j}{\tau}
$$

Подставляем наши авпроксимации и получаем систему из двух неизвестных.

$$
H_i^{j+1} * [-\frac{c_i^j}{\tau}] + u_i^{j+1} * [\frac{H_i^j}{\tau}] = -\frac{c_i^j H_i^j}{\tau} + c_i^{j} L_{\lambda_1}[H]_i^{j} + \frac{H_i^j u_i^j}{\tau} - H_i^j L_{\lambda_1}[u]_i^{j}
$$

$$
H_i^{j+1} * [\frac{c_i^j}{\tau}] + u_i^{j+1} * [\frac{H_i^j}{\tau}] = \frac{c_i^j H_i^j}{\tau} - c_i^{j} L_{\lambda_2}[H]_i^{j} + \frac{h_i^j u_i^j}{\tau} - h_i^j L_{\lambda_2}[u]_i^{j}
$$

Имеем вот такую сетку.

![image](https://user-images.githubusercontent.com/25401699/197346542-cf91ded9-06f2-43d7-9b17-bbdce2298b6e.png)


Здесь зеленым обозначены начальные условия.
Внутренние точки, которые на схеме обозначены просто точками мы можем найти используя предыдущую систему.
Однако, что делать на крайних точках. Из формулы следует, что мы можем выйти за пределы сетки.
Введем граничные условия.

$$
u(x = 0) = u(x = L) = 0
$$

Тогда нам будет достаточно только одного уравнения из системы.
Из анализа системы очевидно следует, что при $$\lambda_k > 0$$ будет явный уголок. То есть берется точка $$i-1$$
Соответственно на левом конце выбираем уравнение, где $$\lambda_k < 0$$ А на правом то, где $$\lambda_k > 0$$

Если на краю нужного уравнения не нашлось, значит получается, что $$|u| > c$$
то есть скорость движения жидкости больше скорости звука, чего быть не может. Поэтому нужно выбирать данные для задачи с умом. С учетом условий УМВ.

## Тестирование

### Колокольная капля

$$L = 1$$

$$u(t = 0) = 0$$

$$H(x, t = 0) = 1 + e^{-500(x-\frac{L}{2})^2}$$

$$u(x = 0, t) = u(x = L, t) = 0$$

![Recording 2022-10-23 at 12 13 26](https://user-images.githubusercontent.com/25401699/197384116-8a98acf4-2a67-475b-af4e-72123cc7eec7.gif)

### Равномерный синус

$$L = 1$$

$$u(t = 0) = 0$$

$$H(x, t = 0) = 0.1 + 0.01\sin(10*\frac{x}{L})$$

$$u(x = 0, t) = u(x = L, t) = 0$$

![Recording 2022-10-23 at 12 25 43](https://user-images.githubusercontent.com/25401699/197384494-035cf517-f02f-498e-9e8c-4af38c5496a7.gif)

Еще вот есть вариант без анимации:

![image](https://user-images.githubusercontent.com/25401699/197385064-111cfd39-23c0-4c81-8190-7a7245933092.png)

## Аналитическое решение

### Линеаризация

Пусть 

$$
u(x, t) = u_0 + \delta u
$$

$$
H(x, t) = H_0 + \delta H
$$

положим тут

$$
H_0 = 1
$$

$$
u_0 = 0
$$

Теперь подставим это в нашу исходную систему.

$$
\begin{cases}
   \frac{\partial}{\partial t}(\delta H) + \frac{\partial}{\partial x}(\delta u (1 + \delta H)) = 0\\
  \frac{\partial}{\partial t}(\delta u + \delta u \delta H) + \frac{\partial}{\partial x}((1 + \delta H)\delta u^2) + g (1+\delta H) \frac{\partial}{\partial x}(\delta H) = 0
\end{cases}\
$$

Или в матричном виде:

$$
\begin{pmatrix}
\frac{\partial \delta H}{\partial t} \\
\frac{\partial \delta u}{\partial t}
\end{pmatrix}
+
\begin{pmatrix}
0 & 1 \\
g & 0
\end{pmatrix}
*
\frac{\partial}{\partial x}
\begin{pmatrix}
\delta H \\
\delta u
\end{pmatrix}
\text{=}
\vec 0
$$

Решим спектральную задачу.

$$
\lambda_1 = \sqrt{g}
$$

$$
\vec l_1 = 
\begin{pmatrix}
1 \\
\sqrt{g}
\end{pmatrix}
$$

$$
\lambda_2 = -\sqrt{g}
$$

$$
\vec l_2 = 
\begin{pmatrix}
-1 \\
\sqrt{g}
\end{pmatrix}
$$

Введем инварианты Римана.

$$
R_1 = (\vec {\delta U} * \vec l_1) = \delta H + \sqrt{g} \delta u
$$


$$
R_2 = (\vec {\delta U} * \vec l_2) = - \delta H + \sqrt{g} \delta u
$$

И тогда имеем два независимых уравнения.

$$
\frac{\partial}{\partial t} R_1 + \sqrt{g} \frac{\partial}{\partial x} R_1 = 0
$$

$$
\frac{\partial}{\partial t} R_2 - \sqrt{g} \frac{\partial}{\partial x} R_2 = 0
$$

Теперь придумаем задачу.
За основу возьмем задачу Коши.
Здесь альфа - мало.

$$
\delta H (t = 0) = \alpha \sin(\frac{\pi x}{L})
$$

$$
\delta u (t = 0) = 0
$$

Тогда начальные условия для инвариантов будут такими:

$$
R_1(t = 0) = \alpha \sin(\frac{\pi x}{L})
$$

$$
R_2(t = 0) = -\alpha \sin(\frac{\pi x}{L})
$$

И тогда общее решение будет такое:

$$
R_1(x, t) = \alpha \sin(\frac{\pi}{L} (x - \sqrt{g} t) )
$$

$$
R_2(x, t) = -\alpha \sin(\frac{\pi}{L}(x + \sqrt{g} t) )
$$

Итоговые решение будут такими:

$$
\delta u = \frac{R_1 + R_2}{2\sqrt{g}} = \frac{\alpha \sin(\frac{\pi}{L} (x - \sqrt{g} t) )-\alpha \sin(\frac{\pi}{L}(x + \sqrt{g} t) )}{2 \sqrt{g}}
$$

$$
\delta H = \frac{R_1 - R_2}{2} = \frac{\alpha \sin(\frac{\pi}{L} (x - \sqrt{g} t) )+\alpha \sin(\frac{\pi}{L}(x + \sqrt{g} t) )}{2}
$$

Тогда можно сгенерировать отсюда и граничные условия:

$$
\delta u(x = 0) = \frac{-\alpha \sin(\frac{\pi}{L\sqrt{g}} t)}{\sqrt{g}}
$$


$$
\delta H(x = 0) = 0
$$

$$
\delta u(x = L) = \frac{\alpha \sin(\frac{\pi}{L\sqrt{g}} t)}{\sqrt{g}}
$$


$$
\delta H(x = L) = 0
$$

Теперь эти начальные и граничные условия можно подать на вход программе и сравнить с линеаризованным решением.

## Двумерное уравнение мелкой воды


Имеем вот такую систему.

$$
\begin{cases}
  \frac{\partial H}{\partial t} + \frac{\partial (H u)}{\partial x} + \frac{\partial (H v)}{\partial y} = 0 \\
  \frac{\partial (H u)}{\partial t} + \frac{\partial}{\partial x}(H u^2 + \frac{1}{2}gH^2) + \frac{\partial}{\partial y} (H u v) = 0 \\
  \frac{\partial (H v)}{\partial t} + \frac{\partial}{\partial x} (H u v) + \frac{\partial}{\partial y}(H v^2 + \frac{1}{2}gH^2) = 0
\end{cases}\
$$

Сделаем замену.

$$
\begin{pmatrix}
H \\
H u \\
H v
\end{pmatrix} =
\begin{pmatrix}
H \\
q \\
p
\end{pmatrix} = \vec U
$$

Тогда можно переписать в матричном виде.

$$
\frac{\partial \vec U}{\partial t} + 
\begin{pmatrix}
0 & 1 & 0 \\
g H - u^2 & 2u & 0 \\
-u v & v & u
\end{pmatrix}
\frac{\partial}{\partial x} \vec U
+
\begin{pmatrix}
0 & 0 & 1 \\
-u v & v & u \\
g H - v^2 & 0 & 2 v
\end{pmatrix}
\frac{\partial}{\partial y} \vec U = 0
$$

У нас появилось две матрицы.
Давайте решим спектральную задачу для обеих.

### Матрица при dx

$$
A = \begin{pmatrix}
0 & 1 & 0 \\
g H - u^2 & 2u & 0 \\
-u v & v & u
\end{pmatrix}
$$

Тогда собственные значения и их собственные векторы будут:

$$
\lambda_1 = u
$$

$$
\vec l_1 = \begin{pmatrix}
0 \\
0 \\
1
\end{pmatrix}
$$


$$
\lambda_2 = u - c
$$

$$
\vec l_2 = \begin{pmatrix}
1 \\
u - c \\
v
\end{pmatrix}
$$


$$
\lambda_3 = u + c
$$

$$
\vec l_3 = \begin{pmatrix}
1 \\
u + c \\
v
\end{pmatrix}
$$

### Матрица при dy

$$
B = \begin{pmatrix}
0 & 0 & 1 \\
-u v & v & u \\
g H - v^2 & 0 & 2 v
\end{pmatrix}
$$

Тогда собственные значения и их собственные векторы будут:

$$
\lambda_1 = v
$$

$$
\vec l_1 = \begin{pmatrix}
0 \\
1 \\
0
\end{pmatrix}
$$


$$
\lambda_2 = v - c
$$

$$
\vec l_2 = \begin{pmatrix}
1 \\
u \\
v - c
\end{pmatrix}
$$


$$
\lambda_3 = v + c
$$

$$
\vec l_3 = \begin{pmatrix}
1 \\
u \\
v + c
\end{pmatrix}
$$

### Численное решение

Будем решать нашу задачу в два этапа.
На первом этапе решаем задачу вот такую:

$$
\frac{\partial}{\partial t} \vec U + A \frac{\partial}{\partial x} \vec U = 0
$$

Будем умножать эта равенство последовательно на i-ый левый собственный вектор матрицы A.

$$
(\vec l_i * \frac{\partial}{\partial t} \vec U) + (\vec l_i * A \frac{\partial}{\partial x} \vec U) = 0
$$

Преобразуем исходя из определения собственного вектора.

$$
(\vec l_i * \frac{\partial}{\partial t} \vec U) + (\vec l_i * \lambda_i \frac{\partial}{\partial x} \vec U) = 0
$$

Теперь будем апроксимировать производную по пространству оператором из одномерного случая.

$$
(\vec l_i * \frac{\partial}{\partial t} \vec U) + (\vec l_i * \lambda_i L_{\lambda_i}[\vec U]) = 0
$$

Теперь апросимируем по времени.

$$
(\vec l_i * \frac{\hat{\vec U} - \vec U}{\tau} + (\vec l_i * \lambda_i L_{\lambda_i}[\vec U]) = 0
$$

Теперь пусть мы уже посчитали сетку на k-ом временном слое. Пусть эта сетка U. Тогда отсюда мы легко найдем U с шляпкой.
Для этого запишем последнее уравнение для всех трех собственных векторов.

$$
\begin{cases}
   p_t + (\vec l_1 * \lambda_1 L_{\lambda_1}[\vec U]) = 0 \\
   H_t + q_t (u-c) + p_t v + (\vec l_2 * L_{\lambda_2}[\vec U] = 0 \\
   H_t + q_t (u+c) + p_t v + (\vec l_3 * L_{\lambda_3}[\vec U] = 0
\end{cases}\
$$

Эту систему можно решить и получить производные по времени в данный момент времени.
После чего, зная апроксимацию 

$$
\vec U_t = \frac{\hat{\vec U} - \vec U}{\tau}
$$

Мы получим значения p, q, H со шляпкой. То есть для нового временного слоя.
Мы нашли U со шляпкой для этой задачи. Теперь будем решать такую задачу:

$$
\frac{\partial}{\partial t} \vec U + B \frac{\partial}{\partial x} \vec U = 0
$$

Действуя аналогично предыдущему случаю, получим следующую систему для нахождения k+1 временного слоя.

$$
\begin{cases}
   q_t + (\vec l_1 * \lambda_1 L_{\lambda_1}[\vec U]) = 0 \\
   H_t + q_t u + p_t (v-c) + (\vec l_2 * L_{\lambda_2}[\vec U] = 0 \\
   H_t + q_t u + p_t (v+c) + (\vec l_3 * L_{\lambda_3}[\vec U] = 0
\end{cases}\
$$

Отсюда снова можем найти q, p, H для следующего временного слоя.

Теперь сделаем следующее:
1. У нас есть k-ый временной слой Uij.
2. Мы решим первую задачу на всех узлах сетки, используя этот слой и получим новый слой Vij.
3. Мы решим вторую задачу на всех узлах сетки, используя промежуточный слой Vij и получим итоговый новый слой в основной задаче.

То есть по сути своей мы как бы вспахиваем двумерную сетку xy как поле. Сначала, решая первой задачей, линиями параллельными оси x.
А потом, решая второй задачей, линией параллельными оси y.

С граничными условиями на каждой такой линии разбираемся аналогично одномерному случаю. То есть смотрим на лямбды и на то, будет ли схема явной или неявной.
Отметим, что в итоговых системах два последних уравнения помогают найти на границе H. А первое согласовать u и v с их граничными условиями, но
если мы на границе требуем равенство скорости нулю, то первое уравнение нам там не понадобится.

# Тестирование

Имеем сетку XoY 30 на 30.
И 200 вперед по времени.

$$
\begin{cases}
h = 0.01\\
\tau = 0.001\\
N = 30\\
M = 200\\
L = N * h = 0.3
\end{cases}
$$

## Экспонента в центре

### Начальные условия

$$
\begin{cases}
H(x, y) = 1 + 0.3*h* \exp(-500*((x-\frac{L}{2})^2 + (y-\frac{L}{2})^2)) \\
u(x, y) = v(x, y) = 0
\end{cases}
$$

![image](https://user-images.githubusercontent.com/25401699/199317900-36ad95fc-f74b-4832-a31f-3734516916e0.png)

### Граничные условия

На границе сетки:

$$
u = v = 0
$$

### Процесс

![test](https://user-images.githubusercontent.com/25401699/199325460-e18ee4fa-093e-46d5-862a-a265464d9224.gif)
