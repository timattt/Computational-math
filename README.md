# Избранные задачи вычислительной математики
В этом репозитории представленны избранные задачи вычислитеьной математики.

## Численное дифференцирование
Задача такая - есть непрерывная функция, нужно взять ее первую и вторую производные. Двумя способами, так чтобы точность была пропрциональна разбиению и его квадрату.

### Простейший случай
Самый простой вариант - это первая производная с первым, где погрешность пропорциональна порядку разбиения.
```
f'n = [f(Xn+1) - f(Xn)] / h;
Xn - сетка аргумента.
f - наша непрерывная функция.
h - размер разбиения.
f'n - сетка производной функции.
```
Такая формула не будет работать на правом краю, поэтому там просто скопируем значение f'n-1.

### Большая точность
Если мы хотим большей точности, то из ряда тейлора можно вывести формулу, которая даст большую точность.
Опустим разложения в ряды. Вот [тут](https://ru.m.wikipedia.org/wiki/%D0%9A%D0%BE%D1%8D%D1%84%D1%84%D0%B8%D1%86%D0%B8%D0%B5%D0%BD%D1%82%D1%8B_%D1%84%D0%BE%D1%80%D0%BC%D1%83%D0%BB_%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B4%D0%B8%D1%84%D1%84%D0%B5%D1%80%D0%B5%D0%BD%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F) есть коэффициенты для более точных формул.

В этой статье есть три таблицы - коэффициенты вперед, назад и симметрично.
Если мы хотим найти f'n, то вперед будет обращаться к Xk только таким, у которых k >= n. Назад, соответственно у которых k <= n. А симметричный вариант использует равное колличество коэффициентов спереди и сзади.

Теперь давайте запишем формулы для первой производной со вторым порядком точности.   
***Коэффициенты вперед:***
```
f'n = [-3/2 * f(Xn) + 2 * f(Xn+1) - 1/2*f(Xn+2)] / h;
```
***Коэффициенты назад:***
```
f'n = [3/2 * f(Xn) + -2 * f(Xn-1) + 1/2*f(Xn-2)] / h;
```
Теперь можно спокойно считать производную.
Будем использовать формулу 'вперед' для всех, кроме двух правых значений. Для них используем формулу 'назад'.
Вот небольшой пример для
```
f(x) = sin(x)
```
На графике можно видеть несколько порядков точности производной. Видно, что второй порядок лучше, чем первый.

![](https://github.com/timattt/Project-computational-math/blob/master/Images/DiffExample.png)

### Эксперимент с порядком точности
Теперь давайте напишем программу, которая для каждой из вышеуказнных формул построит график зависимости погрешности от мелкости разбиения.
Погрешность сетки будем определять как максимум из всех отклонений значений сетки от значения функции в точках сетки.

Добавим еще в наш эксперимент два порядка вторых производных.   
Имеем четыре функции вида:
```
sigma(h) = h ^ p;
sigma - погрешность.
h - мелкость разбиения.
p - порядок.
```
Давайте экспериментально проверим, что для первых двух порядков точности первых двух производных. Точности соответсвенно p = 1 для первого порядка и p = 2 для второго порядка.   

Построим график:

![](https://github.com/timattt/Project-computational-math/blob/master/Images/GraphDiffRaw.png)

По оси X - мелкость разбиения. По оси Y - погрешность.
Можно заметить, что у разной точности разный изгиб линии.
Чтобы найти p, прологарифмируем обе стороны:
```
sigma(h) = h ^ p;
ln(sigma(h)) = ln(h^p);
ln(sigma(h)) = p*ln(h);
```
Теперь построим график с логарифмом:

![](https://github.com/timattt/Project-computational-math/blob/master/Images/GraphDiff.png)

Теперь для каждой линии p - это просто тангенс угла наклона этой линии.
И если посчитать это самое p по графику, то видно, что для первых порядков p = 1, а для вторых p = 2. Т.е. теоретическое предположени выполняется.

### Замечание
В этой задаче нужно использовать при дифференцировании симметричные формулы. Иначе в некоторых ситуациях погрешность может быть иной.   
И вообще лучше всегда во всех задачах брать все симметричное.

## Решение СЛАУ

### Метод Гаусса

Классический метод решения СЛАУ. Рассматриваем невырожденные матрица.
Про сам метод читаем [тут](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%93%D0%B0%D1%83%D1%81%D1%81%D0%B0).

### Метод Гаусса с выбором главного элемента

Очень простая модификация предыдущего. Теперь когда обрабатываем строку выбираем такую, чтобы элемент по модулю был наибольшим.
Подроьнее [здесь](http://www.e-biblio.ru/book/bib/02_estestv_nauki/Vychislit_matematika/pr/docs/piece010.htm).

### Метод Якоби

Простейший итерационный метод

Все нужные формулы ниже:

![](https://github.com/timattt/Project-computational-math/blob/master/Images/JacobTeor.png)

Метод сходится, если det(B) < 1.

### Метод Зейделя

Тоже итерационный метод. Возможно, немного лучше предыдущего, но все равно так себе.

Нужные соотношения ниже:

![](https://github.com/timattt/Project-computational-math/blob/master/Images/ZeidelTeor.png)

Метод сходится, если det( (L + D)^-1 * U ) < 1. L - нижняя треугольная часть. U - верхняя треугольная часть. D - аналогично предыдущему методу. 

### Метод наискорейшего спуска

Самый потрясный итерационный метод для решения СЛАУ.

Теорминимум:

```
Дано:
Ax = f

Итерирование:
rn = Axn - f
Tn = (rn * rn) / (Arn * rn)
xn+1 = xn - Tn*rn

где Tn - число, A - входная матрица, rn - невязка
```

### Метод наименьших невязок

Аналогично предыдущему только формула для Tn другая.
```
Tn = (rn * Arn) / (Arn * Arn)
```

### Метод прогонки

Метод для решения СЛАУ, матрица которых заполнена не нулями только на трех диагоналях.

Описание [тут](https://pro-prof.com/forums/topic/sweep-method-for-solving-systems-of-linear-algebraic-equations)

## Определение корней уравнения

### Метод двоичного поиска

Мы тут люди скромные и всякие эти ваши понтовые названия алгоритмов вроде "дихотомия" не используем!

Алгоритм такой: у нас есть функция f и отрезок [a, b] на этом отрезке у этой функции проживает по постоянной прописке корень. Делим отрезок много раз рекурсивно пополам и находим корень.

Подробности [тут](http://www.machinelearning.ru/wiki/index.php?title=%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B_%D0%B4%D0%B8%D1%85%D0%BE%D1%82%D0%BE%D0%BC%D0%B8%D0%B8)
